Struktur Folder Backend (Node.js + Express + Sequelize)
saas-pos-backend/
src/
â”œâ”€â”€ plugins/                          # Semua modul fitur disusun sebagai plugin
â”‚   â”œâ”€â”€ transaction/
â”‚   â”‚   â”œâ”€â”€ transaction.model.js      # Model Sequelize
â”‚   â”‚   â”œâ”€â”€ transaction.service.js    # Business logic
â”‚   â”‚   â”œâ”€â”€ transaction.controller.js # Route handler
â”‚   â”‚   â”œâ”€â”€ transaction.routes.js     # Express router
â”‚   â”‚   â”œâ”€â”€ transaction.validator.js  # Validasi input (opsional)
â”‚   â”‚   â”œâ”€â”€ plugin.json               # Metadata plugin
â”‚   â”‚   â””â”€â”€ index.js                  # Entry point untuk loader
â”‚   â”œâ”€â”€ inventory/
â”‚   â”‚   â”œâ”€â”€ inventory.model.js
â”‚   â”‚   â”œâ”€â”€ inventory.service.js
â”‚   â”‚   â”œâ”€â”€ inventory.controller.js
â”‚   â”‚   â”œâ”€â”€ inventory.routes.js
â”‚   â”‚   â”œâ”€â”€ plugin.json
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”œâ”€â”€ report/
â”‚   â”‚   â”œâ”€â”€ report.service.js
â”‚   â”‚   â”œâ”€â”€ report.controller.js
â”‚   â”‚   â”œâ”€â”€ report.routes.js
â”‚   â”‚   â”œâ”€â”€ plugin.json
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ pluginLoader/                    # Loader dan helper untuk plugin
â”‚   â”œâ”€â”€ pluginLoader.js              # Fungsi utama untuk load plugin per tenant
â”‚   â”œâ”€â”€ pluginRegistry.js            # Cache & metadata plugin
â”‚   â””â”€â”€ pluginAccessMiddleware.js    # Middleware validasi akses plugin
â”‚
â”œâ”€â”€ shared/                          # Komponen reusable
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.js
â”‚   â”‚   â”œâ”€â”€ rbac.js
â”‚   â”‚   â””â”€â”€ tenantResolver.js        # Ambil tenant dari JWT/subdomain/header
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ logger.js
â”‚   â”‚   â””â”€â”€ responseFormatter.js
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ index.js                 # Inisialisasi Sequelize dan relasi global
â”‚
â”œâ”€â”€ tenants/                         # Konfigurasi & metadata tenant
â”‚   â”œâ”€â”€ config.js                    # (Opsional) konfigurasi statis
â”‚   â””â”€â”€ tenant.service.js           # Ambil data tenant & plugin dari DB
â”‚
â”œâ”€â”€ syncEngine/                      # Modul sinkronisasi offline-online
â”‚   â”œâ”€â”€ syncManager.js
â”‚   â””â”€â”€ conflictResolver.js
â”‚
â”œâ”€â”€ server.js                        # Entry point Express
â””â”€â”€ app.js                           # Inisialisasi Express & plugin loader


project-root/
â”œâ”€â”€ src/                             # Semua source code & plugin
â”‚   â””â”€â”€ ...
â”œâ”€â”€ uploads/                         # File yang diunggah oleh user (gambar, nota, dll)
â”‚   â”œâ”€â”€ tenantA/
â”‚   â”œâ”€â”€ tenantB/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ public/                          # File statis (logo, CSS, JS client-side jika ada)
â”‚   â”œâ”€â”€ images/
â”‚   â”œâ”€â”€ css/
â”‚   â””â”€â”€ js/
â”œâ”€â”€ assets/                          # Optional: file internal seperti template PDF, ikon
â”‚   â”œâ”€â”€ templates/
â”‚   â””â”€â”€ icons/
â”œâ”€â”€ logs/                            # Log file (jika tidak pakai external logger)
â”œâ”€â”€ .env                             # Environment config
â”œâ”€â”€ server.js
â””â”€â”€ package.json

STRUKTUR FORMAT UPLOAD
/uploads/
â”œâ”€â”€ tenants{kode}/
â”‚   â”œâ”€â”€ logo/
â”‚   â”‚   â””â”€â”€ logo.png
â”‚   â””â”€â”€ products/
â”‚   |    â””â”€â”€ product_abc123.jpg
â”‚   â”œâ”€â”€ doc/
â”‚       â””â”€â”€ template.xlm
â”œâ”€â”€ vendor/
â”‚   â”œâ”€â”€ logo/
â”‚   â”‚   â””â”€â”€ logo1.jpg
â”‚   â””â”€â”€ doc/
â”‚       â””â”€â”€ mou.pdf

ðŸ” Auth & RBAC
JWT Middleware: Validasi token dan extract tenant/user info
Role-based Access: Middleware per route (admin, kasir, owner, dll)
Multi-tenant Isolation: Tenant ID di setiap query dan token

ðŸ”„ Sync Engine (Offline-first)
UUID: Sebagai primary key untuk semua data
sync_source: Menandai asal perubahan (mobile, web, sync)
Conflict Resolver: Strategi last-write-wins, merge, atau manual review
Queue System: Gunakan BullMQ atau Agenda untuk job scheduling

ðŸ“¦ File Storage
Gunakan multer untuk upload
Struktur folder sesuai contoh kamu
Bisa diatur untuk pindah ke S3 atau Cloudinary jika butuh CDN

js
// Contoh path generator
function getUploadPath(tenantCode, type, filename) {
  return `/uploads/tenants${tenantCode}/${type}/${filename}`;
}

ðŸ› ï¸ Queue & Jobs
Sync Queue: Proses data dari client offline
Email Queue: Kirim notifikasi atau laporan
Backup Job: Backup data tenant secara berkala


Database options:
Shared DB, shared schema (dengan tenant_id)
Dedicated schema per tenant â†’ lebih isolatif, cocok untuk enterprise

ðŸ”„ Sync Engine & Offline Strategy
Tujuan: Mendukung client offline dan sinkronisasi data yang robust.

ðŸ”¹ Strategi:
UUID sebagai primary key: Hindari konflik antar client.
Conflict Resolver: Mengacu transkasi terakhir

ðŸ“¦ File Storage Modular
Tujuan: File management yang scalable dan tenant-aware.

ðŸ”¹ Strategi:
Multer + Custom Path Resolver: Simpan file sesuai struktur tenant.
Metadata DB: Simpan info file (path, tenant, type) di DB untuk tracking.

contoh modul product yang modular, tenant-aware, dan siap scalable. Modul ini mencakup model, service, controller, dan route, serta integrasi dengan RBAC dan sync engine.

ðŸ“¦ Struktur Modul product
src/modules/product/
â”œâ”€â”€ product.model.js         # Sequelize model
â”œâ”€â”€ product.service.js       # Business logic
â”œâ”€â”€ product.controller.js    # Route handler
â”œâ”€â”€ product.routes.js        # Express router
â”œâ”€â”€ product.validator.js     # Input validation (optional)
â””â”€â”€ index.js                 # Modul entry (opsional untuk plugin-style)
ðŸ§¬ product.model.js
js
const { DataTypes } = require('sequelize');
const sequelize = require('../../config/database');

const Product = sequelize.define('Product', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true
  },
  tenant_id: {
    type: DataTypes.STRING,
    allowNull: false
  },
  name: DataTypes.STRING,
  price: DataTypes.FLOAT,
  image_url: DataTypes.STRING,
  sync_source: DataTypes.STRING,
  updated_at: DataTypes.DATE
}, {
  timestamps: true,
  paranoid: true
});

Product.addScope('byTenant', (tenantId) => ({
  where: { tenant_id: tenantId }
}));

module.exports = Product;
ðŸ§  product.service.js
js
const Product = require('./product.model');

async function createProduct(data, tenantId) {
  return await Product.create({ ...data, tenant_id: tenantId });
}

async function getProducts(tenantId) {
  return await Product.scope({ method: ['byTenant', tenantId] }).findAll();
}

async function updateProduct(id, data, tenantId) {
  const product = await Product.findOne({ where: { id, tenant_id: tenantId } });
  if (!product) throw new Error('Product not found');
  return await product.update(data);
}

module.exports = { createProduct, getProducts, updateProduct };
ðŸŽ¯ product.controller.js
js
const service = require('./product.service');

exports.create = async (req, res, next) => {
  try {
    const tenantId = req.user.tenant_id;
    const product = await service.createProduct(req.body, tenantId);
    res.status(201).json(product);
  } catch (err) {
    next(err);
  }
};

exports.list = async (req, res, next) => {
  try {
    const tenantId = req.user.tenant_id;
    const products = await service.getProducts(tenantId);
    res.json(products);
  } catch (err) {
    next(err);
  }
};
ðŸš¦ product.routes.js
js
const express = require('express');
const controller = require('./product.controller');
const auth = require('../../middleware/auth');
const rbac = require('../../middleware/rbac');

const router = express.Router();

router.use(auth.verifyToken); // JWT auth
router.use(rbac.allowRoles(['admin', 'kasir'])); // Role-based access

router.get('/', controller.list);
router.post('/', controller.create);

module.exports = router;
ðŸ”„ Integrasi Sync Engine (Opsional)
Di product.service.js, kamu bisa tambahkan:

js
// Saat create/update
data.sync_source = 'web';
data.updated_at = new Date();
Dan buat job di syncQueue.js untuk proses data dari client offline.

ðŸ“ Upload Gambar Produk (Opsional)
Tambahkan di product.controller.js:

js
const path = require('path');
const fs = require('fs');

exports.uploadImage = async (req, res) => {
  const tenantId = req.user.tenant_id;
  const filename = `product_${req.body.id}.jpg`;
  const uploadPath = path.join(__dirname, '../../uploads/tenants' + tenantId + '/products/', filename);

  fs.writeFileSync(uploadPath, req.file.buffer);
  res.json({ url: `/uploads/tenants${tenantId}/products/${filename}` });
};

ðŸ“  modul sync, yang jadi jantung strategi offline-first kamu. Modul ini akan menangani data dari client offline, menyimpan perubahan, dan menyelesaikan konflik antar sumber data.

ðŸ”„ Modul sync â€” Offline-First Sync Engine
src/sync/
â”œâ”€â”€ syncManager.js           # Entry point untuk sinkronisasi
â”œâ”€â”€ conflictResolver.js      # Strategi resolusi konflik
â”œâ”€â”€ syncQueue.js             # Job queue untuk proses async
â””â”€â”€ sync.routes.js           # Endpoint untuk client offline
ðŸ§  syncManager.js
js
const Product = require('../modules/product/product.model');
const resolveConflict = require('./conflictResolver');

async function syncData({ model, incomingData, tenantId }) {
  const existing = await model.findOne({ where: { id: incomingData.id, tenant_id: tenantId } });

  if (!existing) {
    return await model.create({ ...incomingData, tenant_id: tenantId });
  }

  const resolved = resolveConflict(existing, incomingData);
  return await existing.update(resolved);
}

module.exports = { syncData };
âš”ï¸ conflictResolver.js
js
function resolveConflict(existing, incoming) {
  // Simple strategy: last-write-wins
  if (new Date(incoming.updated_at) > new Date(existing.updated_at)) {
    return { ...existing.toJSON(), ...incoming };
  }
  return existing.toJSON();
}

module.exports = resolveConflict;
Kamu bisa ganti strategi ini dengan merge, manual review, atau field-level resolution.

ðŸ“¬ syncQueue.js
js
const Queue = require('bullmq').Queue;
const { syncData } = require('./syncManager');
const Product = require('../modules/product/product.model');

const syncQueue = new Queue('sync');

syncQueue.process(async (job) => {
  const { data, modelName, tenantId } = job.data;
  const model = modelName === 'Product' ? Product : null; // Extendable

  if (model) {
    await syncData({ model, incomingData: data, tenantId });
  }
});

module.exports = syncQueue;
ðŸŒ sync.routes.js
js
const express = require('express');
const syncQueue = require('./syncQueue');
const auth = require('../middleware/auth');

const router = express.Router();
router.use(auth.verifyToken);

router.post('/', async (req, res) => {
  const { modelName, data } = req.body;
  const tenantId = req.user.tenant_id;

  await syncQueue.add('sync', { modelName, data, tenantId });
  res.status(202).json({ message: 'Sync job queued' });
});

module.exports = router;
ðŸ§© Integrasi ke App
Di app.js atau index.js:

js
const syncRoutes = require('./sync/sync.routes');
app.use('/api/sync', syncRoutes);
ðŸ”§ Tips Tambahan
Tambahkan sync_source di setiap data (mobile, web, sync)

Simpan log sinkronisasi per tenant untuk audit

Bisa tambahkan sync_token untuk versi data per client